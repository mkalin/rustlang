use std::str::String;

fn main() {
    // immutable binding with a String
    let hi1 = String::from("Hello, world!");
    println!("{}", hi1);

    // mutable binding with a String
    let mut hi2 = String::from("Hello, ");
    hi2.push('w');                          // add a character
    hi2.push_str("orld!");                  // add a string slice
    println!("{}", hi2);

    let empty = String::new();                       // empty string
    println!("length/capacity of empty: {} {}", empty.len(), empty.capacity());
    let mut emptyFor16 = String::with_capacity(16);  // empty with a specified capacity
    for _ in 0..emptyFor16.capacity() {
        emptyFor16.push('A');
    }

    // some bytes, in a vector
    let sparkle_heart = vec![240, 159, 146, 150];

    // We know these bytes are valid, so we'll use `unwrap()`.
    let sparkle_heart = String::from_utf8(sparkle_heart).unwrap();

// as_bytes(), chars()

/*
std::ffi::OsString

The need for this type arises from the fact that:

On Unix systems, strings are often arbitrary sequences of non-zero bytes, in many cases interpreted as UTF-8.

On Windows, strings are often arbitrary sequences of non-zero 16-bit values, interpreted as UTF-16 when it is valid to do so.

In Rust, strings are always valid UTF-8, but may contain zeros.

OsString and OsStr bridge this gap by simultaneously representing Rust and platform-native string values, and in particular 
allowing a Rust string to be converted into an "OS" string with no cost.

*/

// The String contains no chars, even though it has capacity for more
assert_eq!(s.len(), 0);

// These are all done without reallocating...
let cap = s.capacity();
for i in 0..10 {
    s.push('a');
}

assert_eq!(s.capacity(), cap);

// ...but this may make the vector reallocate
s.push('a');
