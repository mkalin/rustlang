
 -- Strings and string slices

 # Strings stored on the heap

 # Rust as a string type std::str::String, which is a struct with the implementation methods one would expect.

   ## A String binding such as 

        let hi = String::from("Hello, world!");

      the name 'hi' has ownership of the string.


let mut hello = String::from("Hello, ");

hello.push('w');
hello.push_str("orld!");

// some bytes, in a vector
let sparkle_heart = vec![240, 159, 146, 150];

// We know these bytes are valid, so we'll use `unwrap()`.
let sparkle_heart = String::from_utf8(sparkle_heart).unwrap();

// as_bytes(), chars()

/*
std::ffi::OsString

The need for this type arises from the fact that:

On Unix systems, strings are often arbitrary sequences of non-zero bytes, in many cases interpreted as UTF-8.

On Windows, strings are often arbitrary sequences of non-zero 16-bit values, interpreted as UTF-16 when it is valid to do so.

In Rust, strings are always valid UTF-8, but may contain zeros.

OsString and OsStr bridge this gap by simultaneously representing Rust and platform-native string values, and in particular 
allowing a Rust string to be converted into an "OS" string with no cost.

*/

let s = String::new();

let mut s = String::with_capacity(10);

// The String contains no chars, even though it has capacity for more
assert_eq!(s.len(), 0);

// These are all done without reallocating...
let cap = s.capacity();
for i in 0..10 {
    s.push('a');
}

assert_eq!(s.capacity(), cap);

// ...but this may make the vector reallocate
s.push('a');
